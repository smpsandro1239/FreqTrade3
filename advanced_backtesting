#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üìä SISTEMA DE BACKTESTING AVAN√áADO - FREQTRADE3
Backtesting completo com dados reais, otimiza√ß√£o e TradingView-like charts
"""

import json
import os
import sys
import warnings
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd
import ta
import yfinance as yf

warnings.filterwarnings('ignore')

@dataclass
class BacktestTrade:
    """Trade no backtest"""
    id: str
    timestamp: datetime
    symbol: str
    side: str  # 'buy' or 'sell'
    quantity: float
    price: float
    commission: float
    pnl: float = 0.0
    balance_after: float = 0.0

@dataclass
class BacktestResult:
    """Resultado completo do backtest"""
    trades: List[BacktestTrade]
    total_return: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    profit_factor: float
    max_drawdown: float
    sharpe_ratio: float
    start_date: datetime
    end_date: datetime
    initial_balance: float
    final_balance: float
    total_pnl: float
    commission_paid: float
    returns_series: pd.Series
    equity_curve: pd.Series
    trades_detail: List[Dict]

class AdvancedBacktestEngine:
    """Motor de backtesting avan√ßado com dados reais"""

    def __init__(self):
        self.data_cache = {}
        self.strategies = {}
        self.commission_rate = 0.001  # 0.1%
        self.initial_balance = 10000  # $10,000
        self.slippage = 0.0005  # 0.05%

    def add_strategy(self, name: str, strategy_func):
        """Adicionar estrat√©gia ao motor"""
        self.strategies[name] = strategy_func

    def fetch_real_data(self, symbol: str, start_date: str, end_date: str,
                       timeframe: str = '1h') -> pd.DataFrame:
        """Buscar dados reais do Yahoo Finance"""
        cache_key = f"{symbol}_{timeframe}_{start_date}_{end_date}"

        if cache_key in self.data_cache:
            return self.data_cache[cache_key]

        try:
            # Mapear timeframes para Yahoo Finance
            tf_map = {
                '1m': '1m', '5m': '5m', '15m': '15m', '30m': '30m',
                '1h': '1h', '4h': '1h', '1d': '1d', '1w': '1wk'
            }

            yf_timeframe = tf_map.get(timeframe, '1h')

            # Tentar baixar dados
            ticker = yf.Ticker(symbol.replace('/', ''))

            # Adicionar per√≠odo de buffer para indicadores
            start_buffer = datetime.strptime(start_date, '%Y-%m-%d') - timedelta(days=30)
            end_date_dt = datetime.strptime(end_date, '%Y-%m-%d')

            data = ticker.history(
                start=start_buffer.strftime('%Y-%m-%d'),
                end=end_date_dt.strftime('%Y-%m-%d'),
                interval=yf_timeframe,
                auto_adjust=True,
                prepost=True
            )

            if data.empty:
                # Fallback para dados simulados mais realistas
                return self.generate_realistic_data(symbol, start_date, end_date, timeframe)

            # Renomear colunas para padr√£o
            data.columns = [col.lower() for col in data.columns]
            data = data.rename(columns={'adj close': 'close'})

            # Filtrar apenas per√≠odo solicitado
            start_dt = pd.to_datetime(start_date)
            end_dt = pd.to_datetime(end_date)
            data = data[(data.index >= start_dt) & (data.index <= end_dt)]

            # Cache dos dados
            self.data_cache[cache_key] = data

            return data

        except Exception as e:
            print(f"‚ùå Erro ao buscar dados reais: {e}")
            return self.generate_realistic_data(symbol, start_date, end_date, timeframe)

    def generate_realistic_data(self, symbol: str, start_date: str,
                               end_date: str, timeframe: str) -> pd.DataFrame:
        """Gerar dados simulados mais realistas baseados em padr√µes reais"""
        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)

        # Mapear timeframes
        freq_map = {
            '1m': '1T', '5m': '5T', '15m': '15T', '30m': '30T',
            '1h': '1H', '4h': '4H', '1d': '1D', '1w': '1W'
        }

        freq = freq_map.get(timeframe, '1H')
        periods = pd.date_range(start_dt, end_dt, freq=freq)

        # Pre√ßos base por s√≠mbolo (2025 data)
        base_prices = {
            'BTC/USDT': 101000, 'ETH/USDT': 3500, 'BNB/USDT': 650,
            'ADA/USDT': 1.25, 'XRP/USDT': 0.68, 'SOL/USDT': 180,
            'DOT/USDT': 12.5, 'LINK/USDT': 25
        }

        base_price = base_prices.get(symbol, 100)

        # Gerar dados com volatilidade realista
        n_periods = len(periods)

        # Volatilidade por timeframe
        volatility_map = {
            '1m': 0.008, '5m': 0.012, '15m': 0.018, '30m': 0.025,
            '1h': 0.035, '4h': 0.05, '1d': 0.08, '1w': 0.12
        }

        daily_vol = volatility_map.get(timeframe, 0.03)

        # Gerar returns com autocorrela√ß√£o e mean reversion
        returns = np.random.normal(0, daily_vol, n_periods)

        # Adicionar tend√™ncias e padr√µes
        trend_strength = 0.3
        for i in range(1, len(returns)):
            # Mean reversion
            if i > 20:
                recent_return = np.mean(returns[max(0, i-20):i])
                returns[i] -= trend_strength * recent_return * 0.1

            # Adicionar volatilidade clusters
            if i % 50 < 10:  # Per√≠odos de alta volatilidade
                returns[i] *= 1.5

        # Calcular pre√ßos
        prices = [base_price]
        for ret in returns[1:]:
            # Adicionar slippage
            slippage_ret = np.random.normal(0, self.slippage)
            new_price = prices[-1] * (1 + ret + slippage_ret)
            prices.append(max(0.01, new_price))

        # Gerar OHLC mais realista
        data = []
        for i, (ts, close) in enumerate(zip(periods, prices)):
            # Simular volatility intraper√≠odo
            intraday_vol = daily_vol * 0.6
            high_mult = 1 + abs(np.random.normal(0, intraday_vol))
            low_mult = 1 - abs(np.random.normal(0, intraday_vol))

            # Open
            if i == 0:
                open_price = close
            else:
                open_price = prices[i-1] * (1 + np.random.normal(0, intraday_vol * 0.3))

            high_price = max(open_price, close) * high_mult
            low_price = min(open_price, close) * low_mult

            # Volume realista
            base_volume = 1000000
            volume_volatility = 0.5
            volume = base_volume * (1 + np.random.normal(0, volume_volatility))
            volume = max(1000, volume)

            data.append({
                'timestamp': ts,
                'open': open_price,
                'high': high_price,
                'low': low_price,
                'close': close,
                'volume': volume
            })

        df = pd.DataFrame(data)
        df.set_index('timestamp', inplace=True)

        return df

    def calculate_indicators(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calcular indicadores t√©cnicos avan√ßados"""
        result = df.copy()

        # RSI
        result['rsi'] = ta.momentum.RSIIndicator(df['close'], window=14).rsi()

        # MACD
        macd = ta.trend.MACD(df['close'])
        result['macd'] = macd.macd()
        result['macd_signal'] = macd.macd_signal()
        result['macd_histogram'] = macd.macd_diff()

        # EMAs
        result['ema_12'] = ta.trend.EMAIndicator(df['close'], window=12).ema_indicator()
        result['ema_26'] = ta.trend.EMAIndicator(df['close'], window=26).ema_indicator()
        result['ema_50'] = ta.trend.EMAIndicator(df['close'], window=50).ema_indicator()
        result['ema_200'] = ta.trend.EMAIndicator(df['close'], window=200).ema_indicator()

        # Bollinger Bands
        bb = ta.volatility.BollingerBands(df['close'], window=20)
        result['bb_upper'] = bb.bollinger_hband()
        result['bb_middle'] = bb.bollinger_mavg()
        result['bb_lower'] = bb.bollinger_lband()

        # Stochastic
        result['stoch_k'] = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close']).stoch()
        result['stoch_d'] = ta.momentum.StochasticOscillator(df['high'], df['low'], df['close']).stoch_signal()

        # Williams %R
        result['williams_r'] = ta.momentum.WilliamsRIndicator(df['high'], df['low'], df['close']).williams_r()

        # Average True Range
        result['atr'] = ta.volatility.AverageTrueRange(df['high'], df['low'], df['close']).average_true_range()

        # Volume indicators
        result['volume_sma'] = df['volume'].rolling(window=20).mean()
        result['volume_ratio'] = df['volume'] / result['volume_sma']

        # Price action
        result['price_change'] = df['close'].pct_change()
        result['price_change_5'] = df['close'].pct_change(5)
        result['price_change_20'] = df['close'].pct_change(20)

        # Support/Resistance levels
        result['pivot_high'] = df['high'][(df['high'].shift(1) < df['high']) & (df['high'].shift(-1) < df['high'])]
        result['pivot_low'] = df['low'][(df['low'].shift(1) > df['low']) & (df['low'].shift(-1) > df['low'])]

        return result

    def run_backtest(self, symbol: str, strategy_name: str, start_date: str,
                    end_date: str, timeframe: str = '1h',
                    initial_balance: float = 10000,
                    commission_rate: float = 0.001) -> BacktestResult:
        """Executar backtest completo"""
        print(f"üöÄ Executando backtest: {symbol} - {strategy_name}")
        print(f"üìÖ Per√≠odo: {start_date} a {end_date}")
        print(f"‚è∞ Timeframe: {timeframe}")

        # Buscar dados reais
        data = self.fetch_real_data(symbol, start_date, end_date, timeframe)

        if data.empty:
            raise ValueError("N√£o foi poss√≠vel obter dados para o backtest")

        # Calcular indicadores
        data = self.calculate_indicators(data)

        # Inicializar vari√°veis
        balance = initial_balance
        position = 0.0  # 0 = sem posi√ß√£o, >0 = long, <0 = short
        position_size = 0.0
        entry_price = 0.0
        trades = []
        equity_curve = []
        returns = []
        trade_id = 0

        # Verificar se estrat√©gia existe
        if strategy_name not in self.strategies:
            raise ValueError(f"Estrat√©gia '{strategy_name}' n√£o encontrada")

        strategy_func = self.strategies[strategy_name]

        # Executar estrat√©gia para cada per√≠odo
        for i, (timestamp, row) in enumerate(data.iterrows()):
            current_price = row['close']

            # Verificar se temos indicadores suficientes
            if i < 50:  # Precisa de dados para indicadores
                equity_curve.append(balance)
                continue

            # Chamar estrat√©gia
            signal = strategy_func(data.iloc[:i+1])

            current_equity = balance + (position * current_price if position != 0 else 0)
            equity_curve.append(current_equity)

            if i > 0:
                daily_return = (current_equity - equity_curve[-2]) / equity_curve[-2]
                returns.append(daily_return)

            # Executar trades baseado em sinais
            if signal == 'buy' and position <= 0:
                # Abrir posi√ß√£o long
                if position < 0:  # Fechar short primeiro
                    pnl = position * (entry_price - current_price)
                    balance += pnl + abs(position * current_price * commission_rate)

                    # Registrar trade de fechamento
                    trade = BacktestTrade(
                        id=f"short_close_{trade_id}",
                        timestamp=timestamp,
                        symbol=symbol,
                        side='sell',
                        quantity=abs(position),
                        price=current_price,
                        commission=abs(position * current_price * commission_rate),
                        pnl=pnl,
                        balance_after=balance
                    )
                    trades.append(trade)

                # Abrir long
                position_size = balance * 0.95 / current_price  # 95% do saldo
                position = position_size
                entry_price = current_price
                trade_id += 1

            elif signal == 'sell' and position >= 0:
                # Abrir posi√ß√£o short
                if position > 0:  # Fechar long primeiro
                    pnl = position * (current_price - entry_price)
                    balance += pnl + position * current_price * commission_rate

                    # Registrar trade de fechamento
                    trade = BacktestTrade(
                        id=f"long_close_{trade_id}",
                        timestamp=timestamp,
                        symbol=symbol,
                        side='sell',
                        quantity=position,
                        price=current_price,
                        commission=position * current_price * commission_rate,
                        pnl=pnl,
                        balance_after=balance
                    )
                    trades.append(trade)

                # Abrir short
                position_size = balance * 0.95 / current_price
                position = -position_size
                entry_price = current_price
                trade_id += 1

            elif signal == 'exit' and position != 0:
                # Fechar posi√ß√£o
                if position > 0:
                    pnl = position * (current_price - entry_price)
                    balance += pnl + position * current_price * commission_rate

                    trade = BacktestTrade(
                        id=f"long_close_{trade_id}",
                        timestamp=timestamp,
                        symbol=symbol,
                        side='sell',
                        quantity=position,
                        price=current_price,
                        commission=position * current_price * commission_rate,
                        pnl=pnl,
                        balance_after=balance
                    )
                else:
                    pnl = position * (entry_price - current_price)
                    balance += pnl + abs(position * current_price * commission_rate)

                    trade = BacktestTrade(
                        id=f"short_close_{trade_id}",
                        timestamp=timestamp,
                        symbol=symbol,
                        side='buy',
                        quantity=abs(position),
                        price=current_price,
                        commission=abs(position * current_price * commission_rate),
                        pnl=pnl,
                        balance_after=balance
                    )

                trades.append(trade)
                position = 0.0
                position_size = 0.0
                entry_price = 0.0
                trade_id += 1

        # Calcular m√©tricas finais
        if trades:
            winning_trades = len([t for t in trades if t.pnl > 0])
            losing_trades = len([t for t in trades if t.pnl < 0])
            total_pnl = sum(t.pnl for t in trades)
            total_commission = sum(t.commission for t in trades)
        else:
            winning_trades = 0
            losing_trades = 0
            total_pnl = 0
            total_commission = 0

        final_balance = balance + (position * data['close'].iloc[-1] if position != 0 else 0)
        total_return = (final_balance - initial_balance) / initial_balance

        # Calcular drawdown
        equity_series = pd.Series(equity_curve)
        peak = equity_series.expanding().max()
        drawdown = (equity_series - peak) / peak
        max_drawdown = drawdown.min()

        # Calcular Sharpe ratio
        if returns and np.std(returns) > 0:
            sharpe_ratio = np.mean(returns) / np.std(returns) * np.sqrt(252)
        else:
            sharpe_ratio = 0

        # Profit factor
        total_wins = sum(t.pnl for t in trades if t.pnl > 0)
        total_losses = abs(sum(t.pnl for t in trades if t.pnl < 0))
        profit_factor = total_wins / total_losses if total_losses > 0 else float('inf') if total_wins > 0 else 0

        return BacktestResult(
            trades=trades,
            total_return=total_return,
            total_trades=len(trades),
            winning_trades=winning_trades,
            losing_trades=losing_trades,
            win_rate=winning_trades / len(trades) if trades else 0,
            profit_factor=profit_factor,
            max_drawdown=max_drawdown,
            sharpe_ratio=sharpe_ratio,
            start_date=datetime.strptime(start_date, '%Y-%m-%d'),
            end_date=datetime.strptime(end_date, '%Y-%m-%d'),
            initial_balance=initial_balance,
            final_balance=final_balance,
            total_pnl=total_pnl,
            commission_paid=total_commission,
            returns_series=pd.Series(returns) if returns else pd.Series(),
            equity_curve=pd.Series(equity_curve),
            trades_detail=[{
                'id': t.id, 'timestamp': t.timestamp, 'symbol': t.symbol,
                'side': t.side, 'quantity': t.quantity, 'price': t.price,
                'pnl': t.pnl, 'balance_after': t.balance_after
            } for t in trades]
        )

# Estrat√©gias pr√©-definidas
def ema_crossover_strategy(data: pd.DataFrame) -> str:
    """Estrat√©gia EMA Crossover"""
    if len(data) < 50:
        return 'hold'

    latest = data.iloc[-1]
    ema_12 = latest['ema_12']
    ema_26 = latest['ema_26']
    ema_50 = latest['ema_50']

    prev_12 = data['ema_12'].iloc[-2]
    prev_26 = data['ema_26'].iloc[-2]

    # Crossover bullish
    if prev_12 <= prev_26 and ema_12 > ema_26 and latest['close'] > ema_50:
        return 'buy'
    # Crossover bearish
    elif prev_12 >= prev_26 and ema_12 < ema_26 and latest['close'] < ema_50:
        return 'sell'

    return 'hold'

def rsi_strategy(data: pd.DataFrame) -> str:
    """Estrat√©gia RSI"""
    if len(data) < 50:
        return 'hold'

    latest = data.iloc[-1]
    rsi = latest['rsi']

    # Oversold - buy signal
    if rsi < 30 and latest['rsi'] > data['rsi'].iloc[-2]:
        return 'buy'
    # Overbought - sell signal
    elif rsi > 70 and latest['rsi'] < data['rsi'].iloc[-2]:
        return 'sell'

    return 'hold'

def macd_strategy(data: pd.DataFrame) -> str:
    """Estrat√©gia MACD"""
    if len(data) < 50:
        return 'hold'

    latest = data.iloc[-1]
    macd = latest['macd']
    signal = latest['macd_signal']
    prev_macd = data['macd'].iloc[-2]
    prev_signal = data['macd_signal'].iloc[-2]

    # Bullish crossover
    if prev_macd <= prev_signal and macd > signal:
        return 'buy'
    # Bearish crossover
    elif prev_macd >= prev_signal and macd < signal:
        return 'sell'

    return 'hold'

def bollinger_bands_strategy(data: pd.DataFrame) -> str:
    """Estrat√©gia Bollinger Bands"""
    if len(data) < 50:
        return 'hold'

    latest = data.iloc[-1]
    close = latest['close']
    bb_upper = latest['bb_upper']
    bb_lower = latest['bb_lower']

    # Compra na banda inferior (oversold)
    if close <= bb_lower * 1.01:
        return 'buy'
    # Venda na banda superior (overbought)
    elif close >= bb_upper * 0.99:
        return 'sell'

    return 'hold'

def multi_indicator_strategy(data: pd.DataFrame) -> str:
    """Estrat√©gia multi-indicador"""
    if len(data) < 50:
        return 'hold'

    latest = data.iloc[-1]

    # Contar sinais bullish
    buy_signals = 0
    sell_signals = 0

    # EMA crossover
    if latest['ema_12'] > latest['ema_26'] and latest['close'] > latest['ema_50']:
        buy_signals += 1
    elif latest['ema_12'] < latest['ema_26'] and latest['close'] < latest['ema_50']:
        sell_signals += 1

    # RSI
    if latest['rsi'] < 30:
        buy_signals += 1
    elif latest['rsi'] > 70:
        sell_signals += 1

    # MACD
    if latest['macd'] > latest['macd_signal']:
        buy_signals += 1
    else:
        sell_signals += 1

    # Bollinger
    if latest['close'] < latest['bb_lower'] * 1.02:
        buy_signals += 1
    elif latest['close'] > latest['bb_upper'] * 0.98:
        sell_signals += 1

    # Decis√£o baseada em consenso
    if buy_signals >= 3:
        return 'buy'
    elif sell_signals >= 3:
        return 'sell'

    return 'hold'

def demo_advanced_backtest():
    """Demonstra√ß√£o do sistema de backtesting avan√ßado"""
    print("üìä DEMO - Sistema de Backtesting Avan√ßado")
    print("=" * 50)

    # Inicializar motor
    engine = AdvancedBacktestEngine()

    # Adicionar estrat√©gias
    engine.add_strategy('EMA_Crossover', ema_crossover_strategy)
    engine.add_strategy('RSI', rsi_strategy)
    engine.add_strategy('MACD', macd_strategy)
    engine.add_strategy('Bollinger', bollinger_bands_strategy)
    engine.add_strategy('Multi_Indicator', multi_indicator_strategy)

    # Executar backtest
    try:
        result = engine.run_backtest(
            symbol='BTC/USDT',
            strategy_name='Multi_Indicator',
            start_date='2025-01-01',
            end_date='2025-11-07',
            timeframe='1h',
            initial_balance=10000
        )

        print(f"\nüìà RESULTADOS DO BACKTEST:")
        print(f"   Per√≠odo: {result.start_date.strftime('%d/%m/%Y')} - {result.end_date.strftime('%d/%m/%Y')}")
        print(f"   Return Total: {result.total_return:.2%}")
        print(f"   Saldo Inicial: ${result.initial_balance:,.2f}")
        print(f"   Saldo Final: ${result.final_balance:,.2f}")
        print(f"   P&L Total: ${result.total_pnl:,.2f}")
        print(f"   Total de Trades: {result.total_trades}")
        print(f"   Trades Winners: {result.winning_trades}")
        print(f"   Trades Losers: {result.losing_trades}")
        print(f"   Win Rate: {result.win_rate:.2%}")
        print(f"   Profit Factor: {result.profit_factor:.2f}")
        print(f"   Max Drawdown: {result.max_drawdown:.2%}")
        print(f"   Sharpe Ratio: {result.sharpe_ratio:.2f}")
        print(f"   Comiss√£o: ${result.commission_paid:,.2f}")

        print(f"\nüìä √öLTIMOS 5 TRADES:")
        for trade in result.trades[-5:]:
            print(f"   {trade.timestamp.strftime('%d/%m %H:%M')} | {trade.side.upper()} | "
                  f"{trade.quantity:.4f} @ ${trade.price:,.2f} | P&L: ${trade.pnl:,.2f}")

    except Exception as e:
        print(f"‚ùå Erro no backtest: {e}")

    print("\nüéâ Demo conclu√≠do!")

if __name__ == "__main__":
    demo_advanced_backtest()
